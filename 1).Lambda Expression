Q1)Java program to demonstrate lambda expressions to implement a user defined functional interface.
   interface FuncInterface{
   void abstractFun(int x);
    default void normalFun(){
    System.out.println("Hello");
    }
    }

   public class LambdaExpression {
   public static void main(String[] args) {
   FuncInterface fobj= (int x) -> System.out.println(2*x);
   fobj.abstractFun(8);
     }
      }

Q2)simple lambda expressions.
   import java.util.ArrayList;

   class LambdaExpression{
    public static void main(String[] args) {
    ArrayList<Integer> arr = new ArrayList<Integer>();
     arr.add(1);
     arr.add(2);
      arr.add(3);

      arr.forEach(n-> System.out.println(n));
      arr.forEach(n->{if(n%2==0)
      System.out.println(n);
     });
    }
    }

Q3) Lambda expression with no parameters.
   interface Test1{
 void print();
}
 class LambdaExpression{
 static void fun(Test1 t) {t.print();}

  public static void main(String[] args) {
   fun(() -> System.out.println("Hello"));
  }
 }

Q4) Lambda expression with a single parameter.
interface Test2{
    void print(Integer p);
}
class LambdaExpression{
    static void fun(Test2 t,Integer p){ t.print(p);}

    public static void main(String[] args) {
        fun(p -> System.out.println(p),10);
    }
}

Q5) Lambda expression with multi parameters.
   interface Test3{
    void print(Integer p1, Integer p2);
  }
   class LambdaExpression{
    static void fun(Test3 t,Integer p1,Integer p2){
        t.print(p1,p2);
    }

    public static void main(String[] args) {
        fun((p1,p2)-> System.out.println(p1+p2),10,20);
}}

Q6) Lambda expression with two parameters.
  interface Test{
    boolean test(int n , int d);
  }
    class LambdaExpression{
        public static void main(String[] args) {
            Test isFactor= (n,d) -> (n%d)==0;
            if(isFactor.test(10,2))
                System.out.println("is factor");
            if(!isFactor.test(10,3))
                System.out.println("is not factor");
        }
    }

Q7) Sorting ArrayList using Lambda Expression Using lambda expression in place of comparator object for defining our own sorting in collections.
    import java.util.ArrayList;
    import java.util.Collections;

     public class LambdaExpression {
     public static void main(String[] args) {
       ArrayList<Integer> al = new ArrayList<>();
       al.add(2);
       al.add(3);
       al.add(4);
       al.add(7);
       al.add(9);
      System.out.println(al);
      Collections.sort(al,((o1, o2) -> (o1>o2) ? -1:(o1<o2)?1:0));
       System.out.println(al);
     }
   }

Q8) Sorting TreeSet using Lambda Expression.
  public class LambdaExpression {
 public static void main(String[] args) {
  TreeSet<Integer> h= new TreeSet<Integer>((o1,o2) -> (o1 > o2) ? -1:(o1 < o2) ? 1:0);
  h.add(41);
  h.add(6);
  h.add(3);
  h.add(2);
  System.out.println(h);
 }
}

Q9) Sorting elements of TreeMap using Lambda Expression: Sorting will be done on the basis of the keys and not its value. 
    public class LambdaExpression {
    public static void main(String[] args) {
     TreeMap<Integer, String> m= new TreeMap<>((o1, o2) -> (o1 > o2)? -1:(o1<o2)?1:0);
     m.put(1,"apple");
    m.put(2,"mango");
    m.put(3,"litchi");
     m.put(4,"banana");
     System.out.println(m);
   }
  }

Q10)Reverse comparator via a lambda expression directly in the call to the TreeSet() constructor.
  public class LambdaExpression {
   public static void main(String[] args) {
  TreeSet<String> ts= new TreeSet<>((aStr,bStr)-> bStr.compareTo(aStr));
  ts.add("A");
  ts.add("B");
  ts.add("C");
  ts.add("D");
  for(String element : ts)
   System.out.println(element);
 }
} 

Q11) Thread using lambda Expression.
public class LambdaExpression {
    public static void main(String[] args) {
        Runnable runnable=()-> {
            for(int i=0; i<=10;i++){
                System.out.println("Hello "+ i);
            }
        };
        Thread childThread= new Thread(runnable);
        childThread.run();
    }
}

Q12) Creating Lambda expression for run() method in functional interface "Runnable".
public class LambdaExpression {
    public static void main(String[] args) {
        Runnable myThread = ()-> {
            Thread.currentThread().setName("MyThread");
            System.out.println(Thread.currentThread().getName()+"is running");
        };
        Thread run = new Thread(myThread);
        run.start();
    }
}

Q13) Multithreading using lambda expressions.
public class LambdaExpression {
    public static void main(String[] args) {
        Runnable basic =()-> {
            String threadName = Thread.currentThread().getName();
            System.out.println("Running common task by " + threadName);
        };
        Thread thread1 = new Thread(basic);
        Thread thread2 = new Thread(basic);
    thread1.start();
    thread2.start();
    }
}

Q14) Serialization and Deserialization of lambda Expression.
//serialize
package Java8;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class Serial {
    public static void main(String[] args) throws IOException {
        LambdaExpression lambdaExpression = new LambdaExpression("kumari somya","somya@gamil.com",20,"bihar");
        FileOutputStream fos = new FileOutputStream("ob.txt");
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(lambdaExpression);
        oos.close();
        oos.close();
        System.out.println("Object stated is transfered to file ob!!");
    }
}

//Deserialize
package Java8;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class Deserial {
    public static void main(String[] args) {
        try{
            FileInputStream fis = new FileInputStream("ob.txt");
            ObjectInputStream ois = new ObjectInputStream(fis);
            LambdaExpression lambdaExpression = (LambdaExpression) ois.readObject();
            lambdaExpression.displayName();
            System.out.println(lambdaExpression.getName());
            System.out.println(lambdaExpression.getEmail());
            System.out.println(lambdaExpression.getAge());
            System.out.println(lambdaExpression.getAddress());
        }catch(IOException ex){
            ex.printStackTrace();
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }
}

//class implementation
public class LambdaExpression implements Serializable {
    private String name;
    transient private String email;
    private int age;
    private String address;

    public LambdaExpression(String name, String email, int age, String address) {
        this.name = name;
        this.email = email;
        this.age = age;
        this.address = address;
    }

    public LambdaExpression() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public void displayName(){
        System.out.println("Hi My name is "+this.name);
    }
}

Q15) Single Lambda Expression.
  @FunctionalInterface
     interface MyNumber {
      double getValue();
}

public class LambdaDemo1 {
    public static void main(String[] args) {
        MyNumber myNumber;
        myNumber = () -> 123.45;
        System.out.println("A fixed value: "+ myNumber.getValue());

        myNumber = () -> Math.random()*100;
        System.out.println("A random value: "+ myNumber.getValue());
        System.out.println("Another random value: "+ myNumber.getValue());

    }
}

Q16) Block Lambda Expression.
@FunctionalInterface
interface NumericFunc {
    int func(int n);
}

public class LambdaDemo1 {
    public static void main(String[] args) {
        NumericFunc factorial = (n) -> {
            int result = 1;
            for(int i=1;i<=n;i++)
                result = i* result;
            return result;
        };
        System.out.println("the factorial of 3 is "+ factorial.func(3));
        System.out.println("the factoral of 5 is "+ factorial.func(5));
    }
}

Q17) Block Lambda Expression.
@FunctionalInterface
interface StringFunc {
    String func(String n);
}

public class LambdaDemo1 {
    public static void main(String[] args) {
        StringFunc reverse = (str) -> {
            String result ="";
            int i;
            for(i=str.length()-1;i >=0;i--)
                result += str.charAt(i);
            return result;
        };
        System.out.println("Lambda reversed is "+ reverse.func("Lambda"));
        System.out.println("Expression reversed is "+ reverse.func("Expression"));
    }
}
